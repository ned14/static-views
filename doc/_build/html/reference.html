
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Reference &#8212; Boost.StaticViews  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Testing" href="tests.html" />
    <link rel="prev" title="Tutorial" href="getting_started.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="reference">
<span id="id1"></span><h1>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#concepts" id="id5">Concepts</a></li>
<li><a class="reference internal" href="#views-and-adaptors" id="id6">Views and Adaptors</a></li>
<li><a class="reference internal" href="#errors" id="id7">Errors</a></li>
<li><a class="reference internal" href="#utility-functions" id="id8">Utility functions</a></li>
<li><a class="reference internal" href="#details" id="id9">Details</a></li>
</ul>
</div>
<div class="section" id="concepts">
<span id="id2"></span><h2><a class="toc-backref" href="#id5">Concepts</a><a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h2>
<dl class="docutils" id="sequence-concept">
<dt>Sequence</dt>
<dd><p class="first">Is a collection of elements of known (at compile-time) size which
provides random access to elements.</p>
<p class="last">To make a type <code class="docutils literal"><span class="pre">S</span></code> model the Sequence concept one needs to specialise
<code class="xref cpp cpp-class docutils literal"><span class="pre">sequence_traits</span></code> for
this type.</p>
</dd>
</dl>
<dl class="docutils" id="view-concept">
<dt>View</dt>
<dd>Is a proxy that provides access into another <a class="reference external" href="view-concept">view</a> or
<a class="reference external" href="sequence-concept">sequence</a>.</dd>
</dl>
<dl class="docutils" id="algorithm-concept">
<dt>Algorithm</dt>
<dd>Is a function that takes a <a class="reference external" href="view-concept">view</a> and returns something
(usually another view).</dd>
</dl>
</div>
<div class="section" id="views-and-adaptors">
<span id="id4"></span><h2><a class="toc-backref" href="#id6">Views and Adaptors</a><a class="headerlink" href="#views-and-adaptors" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv29view_base">
<span id="view_base"></span><span class="target" id="structview__base"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">view_base</code><a class="headerlink" href="#_CPPv29view_base" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base class for all the views. </p>
<p><p>By deriving from <a class="reference internal" href="#_CPPv29view_base" title="view_base"><code class="xref cpp cpp-class docutils literal"><span class="pre">view_base</span></code></a>, you tell StaticView that the
derived class models the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept.</p>
 </p>
<p>Subclassed by detail::concat_impl&lt; Views &gt;, <a class="reference internal" href="#structdetail_1_1raw__view__impl"><span class="std std-ref">detail::raw_view_impl&lt; Sequence &gt;</span></a>, view_adaptor_base&lt; Derived, View &gt;, view_adaptor_base&lt; drop_impl&lt; View &gt;, View &gt;, view_adaptor_base&lt; hashed_impl&lt; BucketCount, BucketSize, View, Hasher &gt;, View &gt;, view_adaptor_base&lt; take_impl&lt; View &gt;, View &gt;, view_adaptor_base&lt; through_impl&lt; View, Proxy &gt;, View &gt;</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv214algorithm_base">
<span id="algorithm_base"></span><span class="target" id="structalgorithm__base"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">algorithm_base</code><a class="headerlink" href="#_CPPv214algorithm_base" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Base class for all the algorithms. </p>
<p><p>By deriving from <a class="reference internal" href="#_CPPv214algorithm_base" title="algorithm_base"><code class="xref cpp cpp-class docutils literal"><span class="pre">algorithm_base</span></code></a>, you tell StaticView that the
derived class models the <a class="reference internal" href="#algorithm-concept"><span class="std std-ref">view</span></a> concept.</p>
 </p>
<p>Subclassed by detail::algorithm_impl&lt; Function, Args &gt;</p>
</dd></dl>

<dl class="class">
<dt>
<span class="target" id="structsequence__traits"></span><em class="property">template </em>&lt;<em class="property">class</em> Sequence&gt;</dt>
<dt id="_CPPv215sequence_traits">
<span id="sequence_traits"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">sequence_traits</code><a class="headerlink" href="#_CPPv215sequence_traits" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Proxy through which StaticViews functions access sequences. </p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Sequence</span><span class="o">&gt;</span> 
<span class="n">struct</span> <span class="n">sequence_traits</span> <span class="p">{</span>
    <span class="n">using</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">;</span>
 
    <span class="n">static</span> <span class="n">constexpr</span> <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">;</span>
 
    <span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">S</span><span class="o">&gt;</span>
    <span class="n">static</span> <span class="n">constexpr</span> <span class="n">reference</span> <span class="n">at</span><span class="p">(</span><span class="n">S</span><span class="o">&amp;&amp;</span> <span class="n">xs</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">size_t</span> <span class="n">i</span><span class="p">)</span> <span class="n">noexcept</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
 </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv28raw_view">
<span id="raw_view__auto"></span><span class="target" id="raw__view_8hpp_1a2c1dfee112e6ae6ce6f92a9a525cccae"></span><em class="property">constexpr</em> auto <code class="descclassname"></code><code class="descname">raw_view</code> = implementation detail<a class="headerlink" href="#_CPPv28raw_view" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A functor for creating raw views of sequences. </p>
<p><div class="math">
\[ \text{raw_view} : \text{Sequence} \to \text{View} \]</div>
</p>
<p><p>Here, <code class="docutils literal"><span class="pre">Sequence</span></code> is any type that models the <a class="reference internal" href="#sequence-concept"><span class="std std-ref">sequence</span></a> concept. The exact type of view created is an
implementation detail. What’s important is that it models the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept.</p>
 </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv24drop">
<span id="drop__auto"></span><span class="target" id="drop_8hpp_1a322ee5c860b93d6bfb5571a028f5e5b2"></span><em class="property">constexpr</em> auto <code class="descclassname"></code><code class="descname">drop</code> = implementation detail<a class="headerlink" href="#_CPPv24drop" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A functor for creating “drop views”. </p>
<p><div class="math">
\[ \text{drop} : \mathbb{N} \to \text{View} \to \text{View} \]</div>
</p>
<p><p>Given a count <code class="docutils literal"><span class="pre">n</span></code> and a view <code class="docutils literal"><span class="pre">xs</span></code>, creates a view of <code class="docutils literal"><span class="pre">xs</span></code> with the
first <code class="docutils literal"><span class="pre">n</span></code> elements dropped. Type of <code class="docutils literal"><span class="pre">xs</span></code> may be anything as long as it
models the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept. The exact type of the
returned view is an implementation detail. What’s important is that it
also models the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Haskell notation is used here, i.e. the function is curried and
<span class="math">\(\text{drop}(n) : \text{View} \to \text{View}\)</span> models the
<a class="reference internal" href="#algorithm-concept"><span class="std std-ref">algorithm</span></a> concept.</p>
</div>
 </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv24take">
<span id="take__auto"></span><span class="target" id="take_8hpp_1a2c20028c5115dcf38063d322f27b4ee1"></span><em class="property">constexpr</em> auto <code class="descclassname"></code><code class="descname">take</code> = implementation detail<a class="headerlink" href="#_CPPv24take" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A functor for creating “take views”. </p>
<p><div class="math">
\[ \text{take} : \mathbb{N} \to \text{View} \to \text{View} \]</div>
</p>
<p><p>Given a count <code class="docutils literal"><span class="pre">n</span></code> and a view <code class="docutils literal"><span class="pre">xs</span></code>, creates a view of the first 
<span class="math">\(min(\text{n}, \text{xs.size}())\)</span> elements of <code class="docutils literal"><span class="pre">xs</span></code>.
Type of <code class="docutils literal"><span class="pre">xs</span></code> may be anything as long as it models the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept. The exact type of the returned view is an
implementation detail. What’s important is that it also models the
<a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Haskell notation is used here, i.e. the function is curried and
<span class="math">\(\text{take}(n) : \text{View} \to \text{View}\)</span> models the
<a class="reference internal" href="#algorithm-concept"><span class="std std-ref">algorithm</span></a> concept.</p>
</div>
 </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv25slice">
<span id="slice__auto"></span><span class="target" id="slice_8hpp_1a18968c488a8b0cdc2697296024da9293"></span><em class="property">constexpr</em> auto <code class="descclassname"></code><code class="descname">slice</code> = implementation detail<a class="headerlink" href="#_CPPv25slice" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A functor for creating “slice views”. </p>
<p><div class="math">
\[ \text{slice} : \mathbb{N} \to \mathbb{N} \to \text{View} \to \text{View} \]</div>
</p>
<p><p>Given a lower bound <code class="docutils literal"><span class="pre">b</span></code>, an upper bound <code class="docutils literal"><span class="pre">e</span></code> and a view <code class="docutils literal"><span class="pre">xs</span></code>, creates
a view of the <code class="docutils literal"><span class="pre">[b,</span> <span class="pre">e)</span></code> part of <code class="docutils literal"><span class="pre">xs</span></code>. Type of <code class="docutils literal"><span class="pre">xs</span></code> may be anything as
long as it models the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept. The exact type
of the returned view is an implementation detail. What’s important is that
it also models the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept.</p>
<p>Calling <code class="docutils literal"><span class="pre">slice(b,</span> <span class="pre">e)(xs)</span></code> is almost equivalent to calling
<code class="docutils literal"><span class="pre">drop(b)(take(e)(xs))</span></code>. The difference is that slice is a single view,
and, for example, calling <a class="reference internal" href="#_CPPv2NK6detail10slice_impl6parentEv" title="detail::slice_impl::parent"><code class="xref cpp cpp-func docutils literal"><span class="pre">parent()</span></code></a> on it will return xs. Calling <code class="docutils literal"><span class="pre">parent()</span></code>
on the drop view of take view of view will return the take view.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Haskell notation is used here, i.e. the function is curried and
<span class="math">\(\text{slice}(b, e) : \text{View} \to \text{View}\)</span> models the
<a class="reference internal" href="#algorithm-concept"><span class="std std-ref">algorithm</span></a> concept.</p>
</div>
 </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv27through">
<span id="through__auto"></span><span class="target" id="through_8hpp_1a10a5a202e599a78286b05fa944a5407e"></span><em class="property">constexpr</em> auto <code class="descclassname"></code><code class="descname">through</code> = implementation detail<a class="headerlink" href="#_CPPv27through" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A functor for creating “through views”. </p>
<p><div class="math">
\[ \text{through} : \text{View} \to \text{View} \to \text{View} \]</div>
</p>
<p><p>Given a view <code class="docutils literal"><span class="pre">proxy</span></code> and a view <code class="docutils literal"><span class="pre">xs</span></code>, creates a view of <code class="docutils literal"><span class="pre">xs</span></code> through
<code class="docutils literal"><span class="pre">proxy</span></code>. Type of <code class="docutils literal"><span class="pre">xs</span></code> may be anything as long as it models the
<a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept. <code class="docutils literal"><span class="pre">proxy</span></code> must be a view of elements of
type <code class="docutils literal"><span class="pre">std::size_t</span></code>. The exact type of the returned view is an
implementation detail. What’s important is that it also models the
<a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Haskell notation is used here, i.e. the function is curried and
<span class="math">\(\text{through}(\text{proxy}) : \text{View} \to \text{View}\)</span> models
the <a class="reference internal" href="#algorithm-concept"><span class="std std-ref">algorithm</span></a> concept.</p>
</div>
 </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv26hashed">
<span id="hashed__auto"></span><span class="target" id="hashed_8hpp_1a19e702f8c5de62522aa325d836d96da4"></span><em class="property">constexpr</em> auto <code class="descclassname"></code><code class="descname">hashed</code> = implementation detail<a class="headerlink" href="#_CPPv26hashed" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A functor for creating “hashed views”. </p>
<p><div class="math">
\[ \text{hashed} : (\text{T} \to \mathbb{N}) \to \text{View} \to \text{View} \]</div>
</p>
<p>Given a hash function <code class="docutils literal"><span class="pre">hf</span></code> and a view <code class="docutils literal"><span class="pre">xs</span></code>, creates a view of <code class="docutils literal"><span class="pre">xs</span></code> which uses hashes as indices to access elements.</p>
<p>So, say, <span class="math">\( \text{hf} : \text{T} \to \mathbb{N} \)</span> is a hash function, <code class="docutils literal"><span class="pre">xs</span></code> is a view of elements of type <code class="docutils literal"><span class="pre">T</span></code>, and <code class="docutils literal"><span class="pre">ys</span> <span class="pre">=</span></code> <a class="reference internal" href="#hashed_8hpp_1a19e702f8c5de62522aa325d836d96da4"><span class="std std-ref">hashed</span></a> <code class="docutils literal"><span class="pre">(hf)(xs)</span></code>. Then</p>
<p><div class="math">
\[ \{ x \in \text{xs} \;\;|\;\; \text{hf}(x) = h \,\%\, \text{ys.bucket_count}() \} = \text{ys}[h] \;, \forall h \in \mathbb{N}\;. \]</div>
</p>
<p><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Haskell notation is used here, i.e. the function is curried and
<span class="math">\(\text{hashed}(\text{hf}) : \text{View} \to \text{View}\)</span> models
the <a class="reference internal" href="#algorithm-concept"><span class="std std-ref">algorithm</span></a> concept.</p>
</div>
 </p>
</dd></dl>

</div>
<div class="section" id="errors">
<h2><a class="toc-backref" href="#id7">Errors</a><a class="headerlink" href="#errors" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv212out_of_bound">
<span id="out_of_bound"></span><span class="target" id="classout__of__bound"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">out_of_bound</code><a class="headerlink" href="#_CPPv212out_of_bound" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Exception that is thrown when an “index out of bounds error” is encountered. </p>
<p>Inherits from exception</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv211full_bucket">
<span id="full_bucket"></span><span class="target" id="classfull__bucket"></span><em class="property">class </em><code class="descclassname"></code><code class="descname">full_bucket</code><a class="headerlink" href="#_CPPv211full_bucket" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Exception that is thrown when an insert into a full bucket is attempted. </p>
<p>Inherits from exception</p>
</dd></dl>

</div>
<div class="section" id="utility-functions">
<h2><a class="toc-backref" href="#id8">Utility functions</a><a class="headerlink" href="#utility-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">class</em> T&gt;</dt>
<dt id="_CPPv212make_wrapperRR1T">
<span id="make_wrapper__TRRCE"></span><span class="target" id="wrapper_8hpp_1a869773653c4df37d23e4e3a96d2841b7"></span><em class="property">constexpr</em> auto <code class="descclassname"></code><code class="descname">make_wrapper</code><span class="sig-paren">(</span>T &amp;&amp;<em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv212make_wrapperRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Makes a wrapper around an rvalue or lvalue reference. </p>
<p>Creates a <a class="reference internal" href="#structdetail_1_1wrapper"><span class="std std-ref">detail::wrapper</span></a> of <code class="docutils literal"><span class="pre">T&amp;</span></code> or <code class="docutils literal"><span class="pre">T&amp;&amp;</span></code> depending on the type of <code class="docutils literal"><span class="pre">x</span></code>. </p>
</dd></dl>

<dl class="class">
<dt>
<span class="target" id="structis__view"></span><em class="property">template </em>&lt;<em class="property">class</em> V&gt;</dt>
<dt id="_CPPv27is_view">
<span id="is_view"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">is_view</code><a class="headerlink" href="#_CPPv27is_view" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks whether <code class="docutils literal"><span class="pre">V</span></code> models the View concept. </p>
<p><p>Metafunction that returns whether <code class="docutils literal"><span class="pre">V</span></code> models the <a class="reference internal" href="#view-concept"><span class="std std-ref">View</span></a> concept:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">View</span><span class="o">&gt;</span> 
<span class="k">struct</span> <span class="nl">is_view</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">view_base</span><span class="p">,</span> <span class="n">View</span><span class="o">&gt;</span> 
<span class="p">{};</span>
</pre></div>
</div>
 </p>
<p>Inherits from std::is_base_of&lt; view_base, V &gt;</p>
</dd></dl>

<dl class="class">
<dt>
<span class="target" id="structis__algorithm"></span><em class="property">template </em>&lt;<em class="property">class</em> V&gt;</dt>
<dt id="_CPPv212is_algorithm">
<span id="is_algorithm"></span><em class="property">struct </em><code class="descclassname"></code><code class="descname">is_algorithm</code><a class="headerlink" href="#_CPPv212is_algorithm" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks whether <code class="docutils literal"><span class="pre">T</span></code> models the Algorithm concept. </p>
<p><p>Metafunction that returns whether <code class="docutils literal"><span class="pre">T</span></code> models the <a class="reference internal" href="#algorithm-concept"><span class="std std-ref">algorithm</span></a> concept:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span> 
<span class="k">struct</span> <span class="nl">is_algorithm</span> <span class="p">:</span> <span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">algorithm_base</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> 
<span class="p">{};</span>
</pre></div>
</div>
 </p>
<p>Inherits from std::is_base_of&lt; algorithm_base, V &gt;</p>
</dd></dl>

</div>
<div class="section" id="details">
<h2><a class="toc-backref" href="#id9">Details</a><a class="headerlink" href="#details" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt>
<span class="target" id="structdetail_1_1wrapper"></span><em class="property">template </em>&lt;<em class="property">class</em> T&gt;</dt>
<dt id="_CPPv2N6detail7wrapperE">
<span id="detail::wrapper"></span><em class="property">struct </em><code class="descclassname">detail::</code><code class="descname">wrapper</code><a class="headerlink" href="#_CPPv2N6detail7wrapperE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wraps an lvalue or an rvalue reference. </p>
<p>This is basically a <code class="docutils literal"><span class="pre">constexpr</span></code> version of <code class="docutils literal"><span class="pre">std::reference_wrapper</span></code>. The difference is that <a class="reference internal" href="#structdetail_1_1wrapper"><span class="std std-ref">detail::wrapper</span></a> can wrap both lvalue and rvalue references. This is just syntactic sugar.</p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">struct</span> <span class="n">wrapper</span> <span class="p">{</span>
    <span class="n">constexpr</span> <span class="n">auto</span> <span class="n">get</span><span class="p">()</span> <span class="n">const</span><span class="o">&amp;</span> <span class="n">noexcept</span><span class="p">(</span><span class="n">whenever</span> <span class="n">possible</span><span class="p">);</span>
    <span class="n">constexpr</span> <span class="n">auto</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;</span>      <span class="n">noexcept</span><span class="p">(</span><span class="n">whenever</span> <span class="n">possible</span><span class="p">);</span>
    <span class="n">constexpr</span> <span class="n">auto</span> <span class="n">get</span><span class="p">()</span> <span class="o">&amp;&amp;</span>     <span class="n">noexcept</span><span class="p">(</span><span class="n">whenever</span> <span class="n">possible</span><span class="p">);</span>

    <span class="n">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">...</span> <span class="n">Args</span><span class="o">&gt;</span>
    <span class="n">constexpr</span> <span class="n">auto</span> <span class="n">operator</span><span class="p">()</span> <span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;...</span><span class="p">)</span> <span class="n">const</span>
        <span class="n">noexcept</span><span class="p">(</span><span class="n">whenever</span> <span class="n">possible</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</p>
<p>Constructors are intentionally not listed. Use <a class="reference internal" href="#wrapper_8hpp_1a869773653c4df37d23e4e3a96d2841b7"><span class="std std-ref">make_wrapper(T&amp;&amp;)</span></a> to create wrappers. </p>
</dd></dl>

<dl class="class">
<dt>
<span class="target" id="structdetail_1_1raw__view__impl"></span><em class="property">template </em>&lt;<em class="property">class</em> Sequence&gt;</dt>
<dt id="_CPPv2N6detail13raw_view_implE">
<span id="detail::raw_view_impl"></span><em class="property">struct </em><code class="descclassname">detail::</code><code class="descname">raw_view_impl</code><a class="headerlink" href="#_CPPv2N6detail13raw_view_implE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inherits from <a class="reference internal" href="#structview__base"><span class="std std-ref">view_base</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6detail13raw_view_impl13raw_view_implER8Sequence">
<span id="detail::raw_view_impl::raw_view_impl__SequenceRCE"></span><span class="target" id="structdetail_1_1raw__view__impl_1a50e1bb662fd9e3568608fa9296d5cd6f"></span><em class="property">constexpr</em> <code class="descname">raw_view_impl</code><span class="sig-paren">(</span>Sequence &amp;<em>xs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail13raw_view_impl13raw_view_implER8Sequence" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a view of <code class="docutils literal"><span class="pre">xs</span></code>. </p>
<p><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It’s annoying to have to specify Sequence template parameter
all the time. For this reason a <a class="reference internal" href="#_CPPv28raw_view" title="raw_view"><code class="xref cpp cpp-var docutils literal"><span class="pre">raw_view</span></code></a> factory
function is provided. Use it instead to construct raw views
of data.</p>
</div>
 <dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">Sequence</span></code>: <p>Must model the <a class="reference internal" href="#sequence-concept"><span class="std std-ref">sequence</span></a> concept.</p>
 </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">xs</span></code>: Reference to the sequence.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6detail13raw_view_impl13raw_view_implER13raw_view_impl">
<span id="detail::raw_view_impl::raw_view_impl__raw_view_implCRCE"></span><span class="target" id="structdetail_1_1raw__view__impl_1a2b3d13760851ce48eabdf78d714d40c1"></span><em class="property">constexpr</em> <code class="descname">raw_view_impl</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N6detail13raw_view_impl13raw_view_implER8Sequence" title="detail::raw_view_impl::raw_view_impl">raw_view_impl</a> <em class="property">const</em>&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail13raw_view_impl13raw_view_implER13raw_view_impl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6detail13raw_view_impl13raw_view_implERR13raw_view_impl">
<span id="detail::raw_view_impl::raw_view_impl__raw_view_implRRCE"></span><span class="target" id="structdetail_1_1raw__view__impl_1ab02f611e61cc306073f1209d624048c1"></span><em class="property">constexpr</em> <code class="descname">raw_view_impl</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N6detail13raw_view_impl13raw_view_implER8Sequence" title="detail::raw_view_impl::raw_view_impl">raw_view_impl</a>&amp;&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail13raw_view_impl13raw_view_implERR13raw_view_impl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Move constructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6detail13raw_view_implaSER13raw_view_impl">
<span id="detail::raw_view_impl::assign-operator__raw_view_implCRCE"></span><span class="target" id="structdetail_1_1raw__view__impl_1aa5f4c97480cf089d64d19fb8e8deba17"></span><em class="property">constexpr</em> <a class="reference internal" href="#_CPPv2N6detail13raw_view_implE" title="detail::raw_view_impl">raw_view_impl</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N6detail13raw_view_implE" title="detail::raw_view_impl">raw_view_impl</a> <em class="property">const</em>&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail13raw_view_implaSER13raw_view_impl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6detail13raw_view_implaSERR13raw_view_impl">
<span id="detail::raw_view_impl::assign-operator__raw_view_implRRCE"></span><span class="target" id="structdetail_1_1raw__view__impl_1ac14100e8edcde716721b1264b8261bce"></span><em class="property">constexpr</em> <a class="reference internal" href="#_CPPv2N6detail13raw_view_implE" title="detail::raw_view_impl">raw_view_impl</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv2N6detail13raw_view_implE" title="detail::raw_view_impl">raw_view_impl</a>&amp;&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail13raw_view_implaSERR13raw_view_impl" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Move assignment operator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail13raw_view_impl4sizeEv">
<span id="detail::raw_view_impl::sizeCCE"></span><span class="target" id="structdetail_1_1raw__view__impl_1a259b0f200fd15df2d8d6ec7a0be5aa10"></span><em class="property">constexpr</em> auto <code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail13raw_view_impl4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the size of the sequence. </p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span>            <span class="k">return</span> <span class="n">sequence_traits</span><span class="o">&lt;</span><span class="n">sequence_type</span><span class="o">&gt;</span><span class="p">::</span><span class="n">size</span><span class="p">();</span> 
</pre></div>
</div>
 <p>This function is required by the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a>
concept. It’s behavior is equivalent to <a class="reference internal" href="#_CPPv2N6detail13raw_view_impl8capacityEv" title="detail::raw_view_impl::capacity"><code class="xref cpp cpp-func docutils literal"><span class="pre">capacity()</span></code></a> function, i.e. it returns
the number of elements in the sequence.</p>
 </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail13raw_view_implixENSt6size_tE">
<span id="detail::raw_view_impl::subscript-operator__std::sCCCE"></span><span class="target" id="structdetail_1_1raw__view__impl_1a82447dda78d829759890d15288414995"></span><em class="property">constexpr</em> auto <code class="descname">operator[]</code><span class="sig-paren">(</span>std::size_t <em class="property">const</em> <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail13raw_view_implixENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Element access. </p>
<p><p>This function is required by the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a>
concept. It provides access to element at index <cite>i</cite>. Return
type is determined by the corresponding specialisation of
<a class="reference internal" href="#_CPPv215sequence_traits" title="sequence_traits"><code class="xref cpp cpp-class docutils literal"><span class="pre">sequence_traits</span></code></a>. It may be a reference to element,
or a value, or something else. Behavior of this function is
well-described by the following code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sequence</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">out_of_bound</span>
</pre></div>
</div>
 </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv2N6detail13raw_view_impl8capacityEv">
<span id="detail::raw_view_impl::capacityCE"></span><span class="target" id="structdetail_1_1raw__view__impl_1ada2d601f0b2ed3656a78f483f4ef7603"></span><em class="property">static</em> <em class="property">constexpr</em> auto <code class="descname">capacity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail13raw_view_impl8capacityEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the size of the sequence. </p>
<p><div class="highlight-default"><div class="highlight"><pre><span></span>            <span class="k">return</span> <span class="n">sequence_traits</span><span class="o">&lt;</span><span class="n">sequence_type</span><span class="o">&gt;</span><span class="p">::</span><span class="n">size</span><span class="p">();</span> 
</pre></div>
</div>
 <p>This function is required by the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a>
concept. It returns the maximum possible number of elements this
view can have. In this case, just the number of elements in the
sequence.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function is marked <cite>static constexpr</cite> and may thus be
freely used in constant expressions.</p>
</div>
 </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt>
<span class="target" id="structdetail_1_1drop__impl"></span><em class="property">template </em>&lt;<em class="property">class</em> View&gt;</dt>
<dt id="_CPPv2N6detail9drop_implE">
<span id="detail::drop_impl"></span><em class="property">struct </em><code class="descclassname">detail::</code><code class="descname">drop_impl</code><a class="headerlink" href="#_CPPv2N6detail9drop_implE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inherits from view_adaptor_base&lt; drop_impl&lt; View &gt;, View &gt;</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6detail9drop_impl9drop_implERR4ViewNSt6size_tE">
<span id="detail::drop_impl::drop_impl__ViewRR.std::sCCE"></span><span class="target" id="structdetail_1_1drop__impl_1a8d910b71e11d48d8f2dbde147b035ef0"></span><em class="property">constexpr</em> <code class="descname">drop_impl</code><span class="sig-paren">(</span>View &amp;&amp;<em>xs</em>, std::size_t <em class="property">const</em> <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail9drop_impl9drop_implERR4ViewNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a view of <code class="docutils literal"><span class="pre">xs</span></code> with the first <code class="docutils literal"><span class="pre">b</span></code> elements dropped. </p>
<p><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It’s annoying to have to specify the View template parameter
all the time. For this reason a <a class="reference internal" href="#_CPPv24drop" title="drop"><code class="xref cpp cpp-var docutils literal"><span class="pre">drop</span></code></a> factory
function is provided. Use it instead to construct drop views.</p>
</div>
 <dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">View</span></code>: <p>Wrapper around a view, i.e. <code class="docutils literal"><span class="pre">typename</span> <span class="pre">View::type</span></code> is a view and
must model the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept.</p>
 </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">xs</span></code>: Rvalue reference to a wrapper around a view. </li>
<li><code class="docutils literal"><span class="pre">b</span></code>: Number of elements to drop. The resulting view will contain <span class="math">\( max(\text{xs.get().size()} - \text{b}, 0)\)</span> elements.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail9drop_impl4sizeEv">
<span id="detail::drop_impl::sizeCCE"></span><span class="target" id="structdetail_1_1drop__impl_1a3d5ca28dea6acea1dbb52918a7e83b1a"></span><em class="property">constexpr</em> auto <code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail9drop_impl4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements viewed. </p>
<p><p>This function is required by the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a>
concept. It never fails unless a call to <code class="docutils literal"><span class="pre">parent().size()</span></code>
fails.</p>
 </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail9drop_impl3mapENSt6size_tE">
<span id="detail::drop_impl::map__std::sCCCE"></span><span class="target" id="structdetail_1_1drop__impl_1af2c2b01c070b96a5ccb88f141c0a5d0f"></span><em class="property">constexpr</em> auto <code class="descname">map</code><span class="sig-paren">(</span>std::size_t <em class="property">const</em> <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail9drop_impl3mapENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>“Maps” index <code class="docutils literal"><span class="pre">i</span></code> to the corresponding index in the parent view. </p>
<p>Let <code class="docutils literal"><span class="pre">xs</span></code> be of type <a class="reference internal" href="#structdetail_1_1drop__impl_1a8d910b71e11d48d8f2dbde147b035ef0"><span class="std std-ref">drop_impl</span></a>. The following relation then holds <div class="math">
\[ \text{xs}[i] = \text{xs.parent}()[\text{xs.map}(i)]\;, \forall i \in \{0, 1, \dots, \text{xs.size}()-1\}. \]</div>
</p>
<p>If the condition <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;</span> <a class="reference internal" href="#structdetail_1_1drop__impl_1a3d5ca28dea6acea1dbb52918a7e83b1a"><span class="std std-ref"><span class="pre">size()</span></span></a></code> is not satisfied, this function throws an <a class="reference internal" href="#classout__of__bound"><span class="std std-ref">out_of_bound</span></a> exception. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt>
<span class="target" id="structdetail_1_1take__impl"></span><em class="property">template </em>&lt;<em class="property">class</em> View&gt;</dt>
<dt id="_CPPv2N6detail9take_implE">
<span id="detail::take_impl"></span><em class="property">struct </em><code class="descclassname">detail::</code><code class="descname">take_impl</code><a class="headerlink" href="#_CPPv2N6detail9take_implE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inherits from view_adaptor_base&lt; take_impl&lt; View &gt;, View &gt;</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6detail9take_impl9take_implERR4ViewNSt6size_tE">
<span id="detail::take_impl::take_impl__ViewRR.std::sCCE"></span><span class="target" id="structdetail_1_1take__impl_1a08bdb3d96f2059fb3082978cc2dd3092"></span><em class="property">constexpr</em> <code class="descname">take_impl</code><span class="sig-paren">(</span>View &amp;&amp;<em>xs</em>, std::size_t <em class="property">const</em> <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail9take_impl9take_implERR4ViewNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a view of <code class="docutils literal"><span class="pre">xs</span></code> consisting of at most <code class="docutils literal"><span class="pre">e</span></code> elements of <code class="docutils literal"><span class="pre">xs</span></code>. </p>
<p><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It’s annoying to have to specify the View template parameter
all the time. For this reason a <a class="reference internal" href="#_CPPv24take" title="take"><code class="xref cpp cpp-var docutils literal"><span class="pre">take</span></code></a> factory
function is provided. Use it instead to construct take views.</p>
</div>
 <dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">View</span></code>: <p>Wrapper around a view, i.e. <code class="docutils literal"><span class="pre">typename</span> <span class="pre">View::type</span></code> is a view and
must model the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept.</p>
 </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">xs</span></code>: Rvalue reference to a wrapper around a view. </li>
<li><code class="docutils literal"><span class="pre">e</span></code>: Number of elements to take. The resulting view will contain <span class="math">\(min(\text{xs.get}()\text{.size}(), \text{e})\)</span> elements.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail9take_impl4sizeEv">
<span id="detail::take_impl::sizeCCE"></span><span class="target" id="structdetail_1_1take__impl_1acadc0bdca66193a5f797b6be26a09ac6"></span><em class="property">constexpr</em> auto <code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail9take_impl4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements viewed. </p>
<p><p>This function is required by the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a>
concept. It never throws.</p>
 </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail9take_impl3mapENSt6size_tE">
<span id="detail::take_impl::map__std::sCCCE"></span><span class="target" id="structdetail_1_1take__impl_1ac1a4d824fb3487992ebb50cde5e4f9be"></span><em class="property">constexpr</em> auto <code class="descname">map</code><span class="sig-paren">(</span>std::size_t <em class="property">const</em> <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail9take_impl3mapENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>“Maps” index <code class="docutils literal"><span class="pre">i</span></code> to the corresponding index in the parent view. </p>
<p>Let <code class="docutils literal"><span class="pre">xs</span></code> be of type <a class="reference internal" href="#structdetail_1_1take__impl_1a08bdb3d96f2059fb3082978cc2dd3092"><span class="std std-ref">take_impl</span></a>. The following relation then holds <div class="math">
\[ \text{xs}[i] = \text{xs.parent}()[\text{xs.map}(i)]\;, \forall i \in \{0, 1, \dots, \text{xs.size}()-1\}. \]</div>
</p>
<p>If the condition <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;</span> <a class="reference internal" href="#structdetail_1_1take__impl_1acadc0bdca66193a5f797b6be26a09ac6"><span class="std std-ref"><span class="pre">size()</span></span></a></code> is not satisfied, this function throws an <a class="reference internal" href="#classout__of__bound"><span class="std std-ref">out_of_bound</span></a> exception. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt>
<span class="target" id="structdetail_1_1slice__impl"></span><em class="property">template </em>&lt;<em class="property">class</em> DropTake&gt;</dt>
<dt id="_CPPv2N6detail10slice_implE">
<span id="detail::slice_impl"></span><em class="property">struct </em><code class="descclassname">detail::</code><code class="descname">slice_impl</code><a class="headerlink" href="#_CPPv2N6detail10slice_implE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inherits from DropTake</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">class</em> View&gt;</dt>
<dt id="_CPPv2N6detail10slice_impl10slice_implERR4View">
<span id="detail::slice_impl::slice_impl__ViewRRCE"></span><span class="target" id="structdetail_1_1slice__impl_1a0ba36a57fa53c5eb87079878ac3a8736"></span><em class="property">constexpr</em> <code class="descname">slice_impl</code><span class="sig-paren">(</span>View &amp;&amp;<em>xs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail10slice_impl10slice_implERR4View" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Converts <code class="docutils literal"><span class="pre">xs</span></code> to “slice view”. </p>
<p><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It’s pretty impossible to specify <code class="docutils literal"><span class="pre">DropTake</span></code> and <code class="docutils literal"><span class="pre">View</span></code>
template parameters correctly. For this reason a <a class="reference internal" href="#_CPPv25slice" title="slice"><code class="xref cpp cpp-var docutils literal"><span class="pre">slice</span></code></a>
factory function is provided. Use it instead to construct slice
views.</p>
</div>
 <dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">View</span></code>: <p>Wrapper around a view, i.e. <code class="docutils literal"><span class="pre">typename</span> <span class="pre">View::type</span></code> is a view and
must model the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept. It is furthermore
assumed that <code class="docutils literal"><span class="pre">View</span></code> is of the form
<code class="docutils literal"><span class="pre">wrapper&lt;drop_impl&lt;wrapper&lt;take_impl&lt;wrapper&lt;V&amp;(&amp;)&gt;&amp;&amp;&gt;&gt;&gt;&amp;&amp;&gt;</span></code> for
some view <code class="docutils literal"><span class="pre">V</span></code>.</p>
 </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">xs</span></code>: Rvalue reference to a wrapper around a take view of a drop view of a view.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail10slice_impl3mapENSt6size_tE">
<span id="detail::slice_impl::map__std::sCCCE"></span><span class="target" id="structdetail_1_1slice__impl_1a75d81cda954774e75508538688b50da5"></span><em class="property">constexpr</em> auto <code class="descname">map</code><span class="sig-paren">(</span>std::size_t <em class="property">const</em> <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail10slice_impl3mapENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>“Maps” index <code class="docutils literal"><span class="pre">i</span></code> to the corresponding index in the parent view. </p>
<p>Let <code class="docutils literal"><span class="pre">xs</span></code> be of type <a class="reference internal" href="#structdetail_1_1slice__impl_1a0ba36a57fa53c5eb87079878ac3a8736"><span class="std std-ref">slice_impl</span></a>. The following relation then holds</p>
<p><code class="docutils literal"><span class="pre">xs[i]</span> <span class="pre">=</span> <span class="pre">xs.</span></code> <a class="reference internal" href="#structdetail_1_1slice__impl_1a4b579c5cd86c6cac63558fcefc5d673b"><span class="std std-ref">parent</span></a> <code class="docutils literal"><span class="pre">()[xs.</span></code> <a class="reference internal" href="#structdetail_1_1slice__impl_1a75d81cda954774e75508538688b50da5"><span class="std std-ref">map</span></a> <code class="docutils literal"><span class="pre">(i)]</span></code> <span class="math">\( \forall i \in \{0, 1, \dots, \text{xs.size}()-1\}\)</span>.</p>
<p>This function and the <a class="reference internal" href="#structdetail_1_1slice__impl_1a4b579c5cd86c6cac63558fcefc5d673b"><span class="std std-ref">parent()</span></a> member function are what distinguish slice view from the “drop view of take view of view”. Although slice is implemented in terms of the latter, this function goes two steps up and thus makes the rest of the library think that slice is a single view. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail10slice_impl6parentEv">
<span id="detail::slice_impl::parentCCE"></span><span class="target" id="structdetail_1_1slice__impl_1a4b579c5cd86c6cac63558fcefc5d673b"></span><em class="property">constexpr</em> auto <code class="descname">parent</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail10slice_impl6parentEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the “parent” view. </p>
<p>Let <code class="docutils literal"><span class="pre">xs_ptr</span></code> be of a pointer to some view. The following relation then holds</p>
<p><code class="docutils literal"><span class="pre">xs_ptr</span> <span class="pre">=</span> <span class="pre">&amp;</span></code> <a class="reference internal" href="#slice_8hpp_1a18968c488a8b0cdc2697296024da9293"><span class="std std-ref">slice</span></a> <code class="docutils literal"><span class="pre">(b,</span> <span class="pre">e)(*xs_ptr).</span></code> <a class="reference internal" href="#structdetail_1_1slice__impl_1a4b579c5cd86c6cac63558fcefc5d673b"><span class="std std-ref">parent</span></a> <code class="docutils literal"><span class="pre">(),</span></code> <span class="math">\(\forall \text{b},\text{e} \in \mathbb{N}\)</span>. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt>
<span class="target" id="structdetail_1_1through__impl"></span><em class="property">template </em>&lt;<em class="property">class</em> View, <em class="property">class</em> Proxy&gt;</dt>
<dt id="_CPPv2N6detail12through_implE">
<span id="detail::through_impl"></span><em class="property">struct </em><code class="descclassname">detail::</code><code class="descname">through_impl</code><a class="headerlink" href="#_CPPv2N6detail12through_implE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inherits from view_adaptor_base&lt; through_impl&lt; View, Proxy &gt;, View &gt;</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv2N6detail12through_impl12through_implERR4ViewRR5Proxy">
<span id="detail::through_impl::through_impl__ViewRR.ProxyRRCE"></span><span class="target" id="structdetail_1_1through__impl_1a59a419b455491c4c6cad516d35ab7333"></span><em class="property">constexpr</em> <code class="descname">through_impl</code><span class="sig-paren">(</span>View &amp;&amp;<em>xs</em>, Proxy &amp;&amp;<em>proxy</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail12through_impl12through_implERR4ViewRR5Proxy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a view of <code class="docutils literal"><span class="pre">xs</span></code> through <code class="docutils literal"><span class="pre">proxy</span></code>. </p>
<p><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It’s annoying to have to specify the <code class="docutils literal"><span class="pre">View</span></code> and <code class="docutils literal"><span class="pre">Proxy</span></code>
template parameters all the time. For this reason a
<a class="reference internal" href="#_CPPv27through" title="through"><code class="xref cpp cpp-var docutils literal"><span class="pre">through</span></code></a> factory function is provided. Use it instead
to construct views through other views.</p>
</div>
 <dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">View</span></code>: <p>Wrapper around a view, i.e. <code class="docutils literal"><span class="pre">typename</span> <span class="pre">View::type</span></code> is a view and
must model the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept.</p>
 </li>
<li><code class="docutils literal"><span class="pre">Proxy</span></code>: <p>Just like <code class="docutils literal"><span class="pre">View</span></code>, a wrapper around a view, i.e.
<code class="docutils literal"><span class="pre">typename</span> <span class="pre">Proxy::type</span></code> must be a view. Furthermore, viewed
elements must be of type <code class="docutils literal"><span class="pre">std::size_t</span></code>.</p>
 </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">xs</span></code>: Rvalue reference to a wrapper around a view. </li>
<li><code class="docutils literal"><span class="pre">proxy</span></code>: Rvalue reference to a wrapper around a view. It is used as a proxy to access elements of <code class="docutils literal"><span class="pre">xs</span></code>, i.e. if <code class="docutils literal"><span class="pre">ys</span> <span class="pre">=</span> <a class="reference internal" href="#structdetail_1_1through__impl"><span class="std std-ref"><span class="pre">through_impl</span></span></a><span class="pre">{xs,</span> <span class="pre">proxy}</span></code>, then <div class="math">
\[ \text{ys}[i] = \text{xs.get}()\!\left[ \text{proxy.get}()[i]\right]\;, \forall i \in \{0,1,\dots,\text{xs.size}() - 1\}. \]</div>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail12through_impl4sizeEv">
<span id="detail::through_impl::sizeCCE"></span><span class="target" id="structdetail_1_1through__impl_1a2abb4dc480f21a570b67ba88f0e27f15"></span><em class="property">constexpr</em> auto <code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail12through_impl4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements viewed. </p>
<p><p>This function is required by the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a>
concept. It just calls <code class="docutils literal"><span class="pre">size()</span></code> on the proxy view. This
function never fails unless a call to <code class="docutils literal"><span class="pre">proxy.size()</span></code>
fails.</p>
 </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail12through_impl3mapENSt6size_tE">
<span id="detail::through_impl::map__std::sCCCE"></span><span class="target" id="structdetail_1_1through__impl_1a12287017d830da1df38741cb7738a9fb"></span><em class="property">constexpr</em> auto <code class="descname">map</code><span class="sig-paren">(</span>std::size_t <em class="property">const</em> <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail12through_impl3mapENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>“Maps” index <code class="docutils literal"><span class="pre">i</span></code> to the corresponding index in the parent view. Actually, it just calls <code class="docutils literal"><span class="pre">operator[]</span></code> on the proxy view. </p>
<p>Let <code class="docutils literal"><span class="pre">ys</span></code> be of type <a class="reference internal" href="#structdetail_1_1through__impl_1a59a419b455491c4c6cad516d35ab7333"><span class="std std-ref">through_impl</span></a>, i.e. <code class="docutils literal"><span class="pre">ys</span> <span class="pre">=</span></code> <a class="reference internal" href="#through_8hpp_1a10a5a202e599a78286b05fa944a5407e"><span class="std std-ref">through</span></a> <code class="docutils literal"><span class="pre">(proxy)(xs)</span></code>. The following relation then holds</p>
<p><code class="docutils literal"><span class="pre">ys.</span></code> <a class="reference internal" href="#structdetail_1_1through__impl_1a12287017d830da1df38741cb7738a9fb"><span class="std std-ref">map</span></a> <code class="docutils literal"><span class="pre">(i)</span> <span class="pre">=</span> <span class="pre">proxy[i],</span></code> <span class="math">\(\forall i \in \{0, 1, \dots, \text{proxy.size}()-1\}.\)</span> </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv2N6detail12through_impl8capacityEv">
<span id="detail::through_impl::capacityCE"></span><span class="target" id="structdetail_1_1through__impl_1ab1f324f4aa5559fe457ec39ecb6abbc8"></span><em class="property">static</em> <em class="property">constexpr</em> auto <code class="descname">capacity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail12through_impl8capacityEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the capacity of this view. </p>
<p><p>This function is required by the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a>
concept. It just calls <code class="docutils literal"><span class="pre">capacity()</span></code> on the proxy view. This
function never fails.</p>
 </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt>
<span class="target" id="structdetail_1_1hashed__impl"></span><em class="property">template </em>&lt;std::size_t <em>BucketCount</em>, std::size_t <em>BucketSize</em>, <em class="property">class</em> View, <em class="property">class</em> Hasher&gt;</dt>
<dt id="_CPPv2N6detail11hashed_implE">
<span id="detail::hashed_impl"></span><em class="property">struct </em><code class="descclassname">detail::</code><code class="descname">hashed_impl</code><a class="headerlink" href="#_CPPv2N6detail11hashed_implE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inherits from view_adaptor_base&lt; hashed_impl&lt; BucketCount, BucketSize, View, Hasher &gt;, View &gt;</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">class</em> HashFunction, std::size_t… <em>Is</em>&gt;</dt>
<dt id="_CPPv2N6detail11hashed_impl11hashed_implERR4ViewRR12HashFunctionRABucketCount *BucketSize_NSt6size_tENSt14index_sequenceIDp2IsEE">
<span class="target" id="structdetail_1_1hashed__impl_1a01d5bdd38a24ad49cdc448dfd2f3af2b"></span><em class="property">constexpr</em> <code class="descname">hashed_impl</code><span class="sig-paren">(</span>View &amp;&amp;<em>xs</em>, HashFunction &amp;&amp;<em>hf</em>, std::size_t (&amp;<em>storage</em>)[BucketCount *BucketSize], std::index_sequence&lt;Is...&gt;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail11hashed_impl11hashed_implERR4ViewRR12HashFunctionRABucketCount *BucketSize_NSt6size_tENSt14index_sequenceIDp2IsEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a hashed view of <code class="docutils literal"><span class="pre">xs</span></code> using <code class="docutils literal"><span class="pre">hf</span></code> as a hash function. </p>
<p><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function requires an initialiser storage as an argument which
is an implementation detail. This constructor is thus not meant to
be used explicitly, use the <a class="reference internal" href="#_CPPv26hashed" title="hashed"><code class="xref cpp cpp-var docutils literal"><span class="pre">hashed</span></code></a> factory function
instead.</p>
</div>
 <dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">BucketCount</span></code>: Number of buckets. </li>
<li><code class="docutils literal"><span class="pre">BucketSize</span></code>: Capacity of each bucket. </li>
<li><code class="docutils literal"><span class="pre">View</span></code>: <p>Wrapper around a view, i.e. <code class="docutils literal"><span class="pre">typename</span> <span class="pre">View::type</span></code> is a view and
must model the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a> concept.</p>
 </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal"><span class="pre">xs</span></code>: Rvalue reference to a wrapper around a view. </li>
<li><code class="docutils literal"><span class="pre">hf</span></code>: Hash function to use. </li>
<li><code class="docutils literal"><span class="pre">storage</span></code>: Array of indices initialised by #hashed_init_impl.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail11hashed_impl13hash_functionEv">
<span id="detail::hashed_impl::hash_functionCCE"></span><span class="target" id="structdetail_1_1hashed__impl_1a6fa63d0e7cad2ad1e38d71682a90ef15"></span><em class="property">constexpr</em> auto <code class="descname">hash_function</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail11hashed_impl13hash_functionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a reference to the hash function. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2NK6detail11hashed_implixENSt6size_tE">
<span id="detail::hashed_impl::subscript-operator__std::sCCCE"></span><span class="target" id="structdetail_1_1hashed__impl_1ac715b4ccb7288d8a615fbfba25b9f0d2"></span><em class="property">constexpr</em> auto <code class="descname">operator[]</code><span class="sig-paren">(</span>std::size_t <em class="property">const</em> <em>hash</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv2NK6detail11hashed_implixENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the bucket corresponding to <code class="docutils literal"><span class="pre">hash</span></code>. </p>
<p><p>This function is required by the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a>
concept. It returns a view of elements that have hash <code class="docutils literal"><span class="pre">hash</span></code>.
If there are no such elements, the returned view will have size
zero.</p>
 </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv2N6detail11hashed_impl12bucket_countEv">
<span id="detail::hashed_impl::bucket_countCE"></span><span class="target" id="structdetail_1_1hashed__impl_1afc14aa02e999360518806f6c00e78da2"></span><em class="property">static</em> <em class="property">constexpr</em> auto <code class="descname">bucket_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail11hashed_impl12bucket_countEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number buckets. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6detail11hashed_impl11bucket_sizeEv">
<span id="detail::hashed_impl::bucket_sizeCE"></span><span class="target" id="structdetail_1_1hashed__impl_1a3de0f484e1b921fb36eb0b13dab6827a"></span><em class="property">static</em> <em class="property">constexpr</em> auto <code class="descname">bucket_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail11hashed_impl11bucket_sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the capacity of each bucket. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv2N6detail11hashed_impl8capacityEv">
<span id="detail::hashed_impl::capacityCE"></span><span class="target" id="structdetail_1_1hashed__impl_1a261e4b2100432e6465c01619f735293f"></span><em class="property">static</em> <em class="property">constexpr</em> auto <code class="descname">capacity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv2N6detail11hashed_impl8capacityEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the capacity of the view. </p>
<p><p>This function is required by the <a class="reference internal" href="#view-concept"><span class="std std-ref">view</span></a>
concept. Hashed view is a view of buckets rather than individual
elements. This function is thus equivalent to
<a class="reference internal" href="#_CPPv2N6detail11hashed_impl12bucket_countEv" title="detail::hashed_impl::bucket_count"><code class="xref cpp cpp-func docutils literal"><span class="pre">bucket_count()</span></code></a>.</p>
 </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Boost.StaticViews</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#concepts">Concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#views-and-adaptors">Views and Adaptors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#errors">Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#utility-functions">Utility functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#details">Details</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tests.html">Testing</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="getting_started.html" title="previous chapter">Tutorial</a></li>
      <li>Next: <a href="tests.html" title="next chapter">Testing</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Tom Westerhout.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/reference.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>