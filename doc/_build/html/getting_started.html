
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Tutorial &#8212; Boost.StaticViews  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Reference" href="reference.html" />
    <link rel="prev" title="Welcome to Boost.StaticViews’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial">
<span id="id1"></span><h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<span id="id2"></span><h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Static Views is a compile-time analogue of
<a class="reference external" href="https://ericniebler.github.io/range-v3/">Ranges TS</a>. Recall the
classification of computations in <code class="docutils literal"><span class="pre">C++</span></code> Louis Dionne introduced in
<a class="reference external" href="http://www.boost.org/doc/libs/1_64_0/libs/hana/doc/html/index.html">Boost.Hana</a>
docs. There are four types of computations in <code class="docutils literal"><span class="pre">C++</span></code>:</p>
<ol class="arabic simple">
<li>Runtime computations.</li>
<li><code class="docutils literal"><span class="pre">constexpr</span></code> computations.</li>
<li>Heterogeneous computations.</li>
<li>Type-level computations.</li>
</ol>
<p>If focus on manipulating containers it seems that we currently have modern
libraries to fill all but one of the quadrants.
<a class="reference external" href="http://en.cppreference.com/w/cpp/algorithm">STL</a>,
<a class="reference external" href="http://www.boost.org/doc/libs/1_64_0/libs/range/doc/html/index.html">Boost.Range</a>
and <a class="reference external" href="https://ericniebler.github.io/range-v3/">Ranges TS</a> focus on the
first quadrant.
<a class="reference external" href="http://www.boost.org/doc/libs/1_64_0/libs/fusion/doc/html/index.html">Boost.Fusion</a>
and Boost.Hana occupy the third. Boost.Hana
actually covers the fourth as well. There is a number of template
metaprogramming libraries submitted for review. They all focus on
type-level computations.</p>
<p>But what about the second quadrant? What is currently the best way to,
say, find the smallest element in the second half of a constexpr C-style
array? Probably something along the lines:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">find_min_second_half</span><span class="p">(</span><span class="n">T</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">xs</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">min</span> <span class="o">=</span> <span class="n">N</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">xs</span><span class="p">[</span><span class="n">min</span><span class="p">])</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">xs</span><span class="p">[</span><span class="n">min</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Is it difficult? No. Is it a good idea to write something like that each
time we want to perform a simple operation on a <code class="docutils literal"><span class="pre">constexpr</span></code> array? I
don’t think so. That’s where <em>StaticViews</em> enters the game. The main goal
of this library is to provide a set of reusable and composable <em>views</em>
to make most common operations one-liners.:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">xs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>

<span class="c1">// The example from above</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">m</span> <span class="o">=</span> <span class="n">xs</span> <span class="o">|</span> <span class="n">drop</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                      <span class="o">|</span> <span class="n">min</span><span class="p">();</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>I used <code class="docutils literal"><span class="pre">constexpr</span></code> C-array as the most well-known example of constexpr
container, but pretty much any compile-time container of known size can
act as a source of data:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">7</span><span class="o">&gt;</span> <span class="n">xs</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">}};</span>
<span class="k">static_assert</span><span class="p">(</span>
  <span class="n">compose</span><span class="p">(</span> <span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">}</span>
         <span class="p">,</span> <span class="n">filter</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">})</span>
         <span class="p">,</span> <span class="n">raw_view</span>
         <span class="p">)(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This is, of course, only valid in <code class="docutils literal"><span class="pre">C++17</span></code>, but this is essentially what
StaticViews is targeted on. The library itself will be written in
<code class="docutils literal"><span class="pre">C++14</span></code>, but constexpr lambdas make the user experience much better.</p>
<p>Initially, the goal of this project was implementation of a <code class="docutils literal"><span class="pre">static_map</span></code>
container. Ideally, one would like to choose a memory layout policy,
error handling policy, searching algorithm, comparison function, hash
function and much more. At this point, it seems easier to follow the path
of
<a class="reference external" href="http://www.boost.org/doc/libs/1_64_0/libs/multi_index/doc/index.html">Boost.MultiIndex</a>
and to provide building blocks which everyone can combine into a container
suitable for his use case.</p>
<p>Although, we currently can’t create a <code class="docutils literal"><span class="pre">constexpr</span></code> linked list where
linking is achieved through pointers, we can create a linked list using
indices. The following picture
illustrates it further</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>normal linked list                 list based on indices

+-------+------+&lt;&lt;&lt; nullptr          +-------+-------+
| DATA0 | PTRS |                     | DATA0 | -1, 2 |
+-------+------+&gt;&gt;&gt;-+                +-------+-------+
                    |
+-------+------+&lt;&lt;&lt;-|--------+       +-------+-------+
| DATA1 | PTRS |    |        |       | DATA1 |  3, 4 |
+-------+------+&gt;&gt;&gt;-|---+    |       +-------+-------+
                    |   |    |
+-------+------+&lt;&lt;&lt;-+   |    |       +-------+-------+
| DATA2 | PTRS |        |    |       | DATA2 |  0, 3 |
+-------+------+&gt;&gt;&gt;-+   |    |       +-------+-------+
                    |   |    |
+-------+------+&lt;&lt;&lt;-+   |    |       +-------+-------+
| DATA3 | PTRS |        |    |       | DATA3 |  2, 1 |
+-------+------+&gt;&gt;&gt;-----|---&gt;+       +-------+-------+
                        |
+-------+------+&lt;&lt;&lt;-----+            +-------+-------+
| DATA4 | PTRS |                     | DATA4 | 1, -1 |
+-------+------+&gt;&gt;&gt; nullptr          +-------+-------+
</pre></div>
</div>
<p>Data structure on the right can easily be implemented in <code class="docutils literal"><span class="pre">constexpr</span></code>.
But do we actually need something like that? We can just save the
<em>permutation</em> of elements in another array.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>+---+---+---+---+---+
| 0 | 2 | 3 | 1 | 4 |
+---+---+---+---+---+
</pre></div>
</div>
<p>We get previous/next elements by looking at left/right neighbour.
Naturally, we arrive at the concept of a <em>view</em>. A view is something
that provides us with indexed access of our data. To abstract away
from how this data is actually represented, we define sequence
traits:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Sequence</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">sequence_traits</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">size</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="nf">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">at</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="o">??</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>StaticViews defines a single view called <code class="docutils literal"><span class="pre">raw_view</span></code> that adds
<em>view interface</em> to the sequence. This allows to only think in terms
of views and totally forget about sequences (I believe this is done
in Ranges TS using a class that’s even named <code class="docutils literal"><span class="pre">view_interface</span></code>).
Now that we’ve moved sequences out of the picture, we turn to views.
What we want from a <code class="docutils literal"><span class="pre">View</span></code> is something along the lines:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="o">&gt;</span> <span class="c1">// Container type we are viewing</span>
                   <span class="c1">// which is usually again a View.</span>
<span class="k">struct</span> <span class="n">View</span> <span class="p">{</span>
  <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">begin</span><span class="p">();</span> <span class="c1">// Give me an iterator to the beginning</span>
  <span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">end</span><span class="p">();</span> <span class="c1">// Returns a sentinel.</span>

  <span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">size</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span> <span class="c1">// (OPTIONAL)</span>
                                        <span class="c1">// How many elements can</span>
                                        <span class="c1">// I see through this view.</span>

  <span class="k">constexpr</span> <span class="nf">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="p">[](</span><span class="n">T</span> <span class="n">i</span><span class="p">);</span> <span class="c1">// Give me the element at</span>
                                            <span class="c1">// index `i`.</span>
  <span class="c1">// ?? constexpr auto map_to_parent(T i);</span>
  <span class="c1">// ?? constexpr auto parent();</span>

  <span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">capacity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span> <span class="c1">// What&#39;s an upper</span>
                                                   <span class="c1">// bound on the</span>
                                                   <span class="c1">// number of elements</span>
                                                   <span class="c1">// in C?</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now why do we need each of these functions?</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">begin</span></code> and <code class="docutils literal"><span class="pre">end</span></code></dt>
<dd>are the bare bones of ranges. Although we live in constexpr land and
can do everything with indices, iterators provide a nice way to
express forward ranges, because, <code class="docutils literal"><span class="pre">size()</span></code> for a forward range is
<span class="math">\(\mathcal{O}(N)\)</span>.</dd>
<dt><code class="docutils literal"><span class="pre">size</span></code></dt>
<dd>returns the number of elements in the view.</dd>
<dt><code class="docutils literal"><span class="pre">capacity</span></code></dt>
<dd>is required to return an upper bound on the number of elements in this
view. Thus we always have <code class="docutils literal"><span class="pre">size()</span> <span class="pre">&lt;=</span> <span class="pre">capacity</span></code>. We need this function
to be able to determine the size of a buffer. For example, if we want
to have random access into a filtered range, we need the filter view
to store the indices of “good” elements in an internal buffer. But we
need the size of this buffer before filtering, i.e. before we know
what <code class="docutils literal"><span class="pre">size()</span></code> is. <code class="docutils literal"><span class="pre">capacity()</span></code> function solves this problem. Yes,
we use somewhat more storage than necessary, but we gain random access.</dd>
<dt><code class="docutils literal"><span class="pre">operator[]</span></code></dt>
<dd>provides indexed access to the data. Notice that I haven’t
specified the index type to be used. It can differ per View. Although
for random access iterators it is usual to have
<code class="docutils literal"><span class="pre">begin()[i]</span> <span class="pre">==</span> <span class="pre">operator[](i)</span></code>, it is not required.</dd>
</dl>
<p>Views can be divided into two categories: stateful and stateless.
Examples of stateless views are <code class="docutils literal"><span class="pre">drop</span></code>, <code class="docutils literal"><span class="pre">drop_while</span></code>, <code class="docutils literal"><span class="pre">stride</span></code>.
For these views <code class="docutils literal"><span class="pre">operator[]</span></code> can be written as a composition of
some function <code class="docutils literal"><span class="pre">map:</span></code> <span class="math">\(T \to T\)</span> that performs some operations
on the index <code class="docutils literal"><span class="pre">i</span></code>, and a call to <code class="docutils literal"><span class="pre">parent().operator[]</span></code>. For example, <code class="docutils literal"><span class="pre">drop(n)</span></code>’s <code class="docutils literal"><span class="pre">operator[]</span></code> can be implemented as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">constexpr</span> <span class="k">auto</span> <span class="k">operator</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">const</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">parent</span><span class="p">()[</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Such views are very much like the views in Ranges TS, because they
provide constant time copy constructors.</p>
<p>An example of a stateful view is <em>eager</em> <code class="docutils literal"><span class="pre">filter</span></code>. Indeed, to provide
random access, we keep an array of “good” indices. That’s our state.
Although <code class="docutils literal"><span class="pre">capacity</span></code> is fixed upon compilation and thus copying such
an array is <code class="docutils literal"><span class="pre">O(1)</span></code>, I still like to think about it as being <code class="docutils literal"><span class="pre">O(N)</span></code>.
I called this filter eager, because there is also a <em>lazy</em> filter,
one that does the filtering on an as-needed basis. The problem with
eager filtering is that chaining many such filters results in a
substantial extra memory being used. Lazy filtering is not perfect
either, it doesn’t provide random access to elements and may perform
many calls to the predicate function. So a compromise could be reached
by an <code class="docutils literal"><span class="pre">optimise()</span></code> function. The idea is that it takes a view of
a view of a view of a view … of a sequence and claps this whole chain
into a single view of a sequence.</p>
<p>There is one view that deserves some extra attention – <code class="docutils literal"><span class="pre">hashed</span></code> view.
First of all, it is terribly inefficient to use buckets to solve
collisions. Open adressing is the way to go. This means that we have
to keep an array which size is larger than the amount of elements. But
then we can’t say in <code class="docutils literal"><span class="pre">O(1)</span></code> time which is the <code class="docutils literal"><span class="pre">i</span></code>’th occupied element.
What would be nice is to receive a <em>hash</em> as an index and return a view
of elements that (possibly) have the same hash. This allows to decouple
hashing and comparing of elements: <code class="docutils literal"><span class="pre">hashed</span></code> view only knows how to hash
an element, and search algorithm receives a predicate to compare the
elements. Say, we have a hashed view of a dictionary (list of words) and
use word length as a hash. We can then easily obtain all the four-letter
words that have at least two vowels by asking the hashed view for all
words with four letters and the filtering out the ones with less than two
vowels.</p>
<p>Just like in Boost.Range and Ranges TS, we can also have <em>algorithms</em> that
manipulate views. An algorithm is a function <code class="docutils literal"><span class="pre">f</span></code><span class="math">\(View_1 \to R\)</span>,
i.e. taking a view and producing some result. On top of the usual call
operator we also overload <code class="docutils literal"><span class="pre">operator|</span></code> for algorithms. This allows to use
them as pipes. If we have multiple algorithms with <code class="docutils literal"><span class="pre">R</span></code> being some view,
we can chain them as <code class="docutils literal"><span class="pre">view</span> <span class="pre">|</span> <span class="pre">f1</span> <span class="pre">|</span> <span class="pre">f2</span> <span class="pre">|</span> <span class="pre">....</span> <span class="pre">|</span> <span class="pre">fn</span></code>. This also provides a
way to use the <code class="docutils literal"><span class="pre">optimise</span></code> function automatically: if <code class="docutils literal"><span class="pre">operator|</span></code>
detects that the view on the left is an <em>rvalue</em>, it can optimise it away.
We then repeat this operation recusively until an <em>lvalue</em> is encountered.</p>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="static-map">
<h3>Static Map<a class="headerlink" href="#static-map" title="Permalink to this headline">¶</a></h3>
<p>Let’s start by implementing a toy <code class="docutils literal"><span class="pre">static_map</span></code>. We base is on <code class="docutils literal"><span class="pre">hashed</span></code>
view of key-value pairs. The trickiest part is <code class="docutils literal"><span class="pre">operator[]</span></code> of
<code class="docutils literal"><span class="pre">static_map</span></code>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">constexpr</span> <span class="nf">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="k">operator</span><span class="p">[](</span><span class="n">key_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// _hv is the hashed view.</span>
  <span class="c1">// _eq is the comparison function</span>
  <span class="c1">// For simplicity, let&#39;s use C++17 constexpr lambdas. If C++14</span>
  <span class="c1">// compatibility is required, it&#39;s easy to rewrite this using a</span>
  <span class="c1">// struct.</span>
  <span class="k">return</span> <span class="n">find_if</span><span class="p">(</span><span class="n">_hv</span><span class="p">[</span><span class="n">_hv</span><span class="p">.</span><span class="n">hash_function</span><span class="p">()(</span><span class="n">k</span><span class="p">)],</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">k</span><span class="p">,</span> <span class="k">this</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_eq</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">first</span><span class="p">);</span> <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We ask hashed view for a view of all the elements that (possibly) have the
same hash as <code class="docutils literal"><span class="pre">k</span></code>. Then we perform a linear search through this view. It
doesn’t get any simpler than that. Construction of static_map is also
quite simple:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span> <span class="k">class</span> <span class="nc">Sequence</span>
         <span class="p">,</span> <span class="k">class</span> <span class="nc">Pred</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">less</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span>
         <span class="p">,</span> <span class="k">class</span> <span class="nc">Hasher</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="c1">// assume for a minute that</span>
                                          <span class="c1">// it&#39;s constexpr</span>
         <span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">make_static_map</span><span class="p">(</span><span class="n">Sequence</span><span class="o">&amp;</span> <span class="n">xs</span><span class="p">,</span> <span class="n">Pred</span><span class="o">&amp;&amp;</span> <span class="n">equal</span> <span class="o">=</span> <span class="n">Pred</span><span class="p">{},</span>
  <span class="n">Hasher</span><span class="o">&amp;&amp;</span> <span class="n">hash_function</span> <span class="o">=</span> <span class="n">Hasher</span><span class="p">{})</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">hashed_view</span>  <span class="o">=</span> <span class="n">xs</span> <span class="o">|</span> <span class="n">hashed</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Hasher</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hash_function</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">static_map</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">hashed_view</span><span class="p">),</span> <span class="n">Pred</span><span class="o">&gt;</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">hashed_view</span><span class="p">),</span>
    <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Pred</span><span class="o">&gt;</span><span class="p">(</span><span class="n">equal</span><span class="p">)};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We let <code class="docutils literal"><span class="pre">operator|</span></code> do all the work of adopting the sequence <code class="docutils literal"><span class="pre">xs</span></code>.
Notice that template arguments of <code class="docutils literal"><span class="pre">static_map</span></code> are <code class="docutils literal"><span class="pre">HashedView</span></code> and
<code class="docutils literal"><span class="pre">Pred</span></code> in place of common <code class="docutils literal"><span class="pre">Key</span></code>, <code class="docutils literal"><span class="pre">Tp</span></code>, <code class="docutils literal"><span class="pre">Pred</span></code>, <code class="docutils literal"><span class="pre">Hasher</span></code>.
We can easily extract these types from the <code class="docutils literal"><span class="pre">HashedView</span></code>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span> <span class="k">decltype</span><span class="p">(</span>
  <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">HashedView</span><span class="o">&gt;</span><span class="p">()[</span><span class="n">std</span><span class="o">::</span><span class="n">devlval</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">()].</span><span class="n">begin</span><span class="p">()</span> <span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">key_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">value_type</span><span class="o">::</span><span class="n">first</span><span class="p">;</span>
<span class="k">using</span> <span class="n">mapped_type</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">value_type</span><span class="o">::</span><span class="n">second</span><span class="p">;</span>
<span class="k">using</span> <span class="n">key_equal</span> <span class="o">=</span> <span class="n">Pred</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hasher</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">HashedView</span><span class="o">::</span><span class="n">hasher</span><span class="p">;</span>
<span class="k">using</span> <span class="n">reference</span> <span class="o">=</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">const_reference</span> <span class="o">=</span> <span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">difference_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">ptrdiff_t</span><span class="p">;</span>
<span class="k">using</span> <span class="n">size_type</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">;</span>
<span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">HashedView</span><span class="o">::</span><span class="n">iterator</span><span class="p">;</span>
<span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">HashedView</span><span class="o">::</span><span class="n">const_iterator</span><span class="p">;</span>
</pre></div>
</div>
<p>There is some boilerplate code to write, but apart from that we’re done.</p>
</div>
<div class="section" id="parsing-strings-at-compile-time">
<h3>Parsing Strings at Compile Time<a class="headerlink" href="#parsing-strings-at-compile-time" title="Permalink to this headline">¶</a></h3>
<p>Strings are sequences of characters, so they may very well be used with
StaticViews. For example, let’s verify that all brackets match in a string
literal:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">Is</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">are_brackets_good_impl</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xs</span><span class="p">)[</span><span class="n">N</span><span class="p">],</span>
  <span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">Is</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">Counter</span> <span class="p">{</span>
    <span class="kt">int</span>  <span class="n">n</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">good</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;(&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">n</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;)&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">n</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="n">good</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="n">Counter</span> <span class="n">counter</span><span class="p">;</span>
  <span class="n">for_each</span><span class="p">(</span><span class="n">raw_view</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">counter</span><span class="p">.</span><span class="n">good</span> <span class="o">&amp;&amp;</span> <span class="n">counter</span><span class="p">.</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">are_brackets_good</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">xs</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">are_brackets_good_impl</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="p">}</span>

<span class="c1">// later on</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">are_brackets_good</span><span class="p">(</span><span class="s">&quot;(1 + (2))&quot;</span><span class="p">),</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">are_brackets_good</span><span class="p">(</span><span class="s">&quot;(1 + ))(2&quot;</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Although this particular example doesn’t use much of StaticViews
functionality, it illustrates the point that with <code class="docutils literal"><span class="pre">constexpr</span></code> we don’t
have to use <code class="docutils literal"><span class="pre">template</span> <span class="pre">&lt;char...&gt;</span></code> whenever we want results at compile
time. Not only is code using ranges easier to write, it also runs faster,
because no recusive instantiations are used.</p>
<p>As a more difficult example, let’s write a <code class="docutils literal"><span class="pre">printf</span></code> <em>functor</em>. For
simplicity, we will only support format specifiers of the form <code class="docutils literal"><span class="pre">%type</span></code>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">format_spec</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">code</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To check whether the user passed correct types we create a mapping from
type to a char code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">type_to_code</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">type_to_code</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>   <span class="p">{</span> <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="n">value</span> <span class="o">=</span> <span class="sc">&#39;d&#39;</span><span class="p">;</span> <span class="p">};</span>
<span class="k">template</span> <span class="o">&lt;&gt;</span> <span class="k">struct</span> <span class="n">type_to_code</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="n">value</span> <span class="o">=</span> <span class="sc">&#39;f&#39;</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
</div>
<p>This way we also get support for user-defined types – one only
needs to register a type by specializing <code class="docutils literal"><span class="pre">type_to_code</span></code>.</p>
<p>Without loss of generality we can assume the format string to look like
<code class="docutils literal"><span class="pre">STR</span> <span class="pre">(FMT</span> <span class="pre">STR)*</span></code>, where <code class="docutils literal"><span class="pre">STR</span></code> are just some chars we need to print and
<code class="docutils literal"><span class="pre">FMT</span></code> is a format specifier. <code class="docutils literal"><span class="pre">STR</span></code> can also have zero length.</p>
<p>We don’t know the number of <code class="docutils literal"><span class="pre">STR</span></code> and <code class="docutils literal"><span class="pre">FMT</span></code> pieces in out format
string. We do know, however, that length of <code class="docutils literal"><span class="pre">FMT</span></code> is at least 2 (<code class="docutils literal"><span class="pre">%</span></code>
and type code). Thus number of <code class="docutils literal"><span class="pre">FMT</span></code> pieces is bounded from above by
half of the length of the format string. A handy data structure for this
case is a static_vector:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// A vector with fixed-size underlying storage.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">static_vector</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span>      <span class="n">size</span><span class="p">;</span>

    <span class="k">constexpr</span> <span class="nf">static_vector</span><span class="p">()</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">static_vector</span><span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">make_index_sequence</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">{}}</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">push_back</span><span class="p">(</span><span class="n">T</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="n">data</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="o">++</span><span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">...</span> <span class="n">Is</span><span class="o">&gt;</span>
    <span class="k">constexpr</span> <span class="n">static_vector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">index_sequence</span><span class="o">&lt;</span><span class="n">Is</span><span class="p">...</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="o">:</span> <span class="n">data</span><span class="p">{</span> <span class="p">((</span><span class="kt">void</span><span class="p">)</span><span class="n">Is</span><span class="p">,</span> <span class="n">T</span><span class="p">{})...</span> <span class="p">}</span>
        <span class="p">,</span> <span class="n">size</span><span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We need a function to read a piece of format string which up to the next
format specifier:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Parses the STR part, returns the length</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">S</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">next_length</span><span class="p">(</span><span class="n">S</span><span class="o">&amp;&amp;</span> <span class="n">xs</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">xs</span> <span class="o">|</span> <span class="n">take_while</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">!=</span> <span class="sc">&#39;%&#39;</span><span class="p">;</span> <span class="p">})).</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And for the <code class="docutils literal"><span class="pre">FMT</span></code> part:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// Parses the FMT part, returns format_spec</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">S</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">parse_format</span><span class="p">(</span><span class="n">S</span><span class="o">&amp;&amp;</span> <span class="n">xs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">format_spec</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">xs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;%&#39;</span><span class="p">)</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">{</span><span class="s">&quot;&quot;</span><span class="p">};</span>
        <span class="k">return</span> <span class="p">{</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And finally we can write the <code class="docutils literal"><span class="pre">parse</span></code> function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="c1">// The parsing function</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">parse</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">xs</span><span class="p">)[</span><span class="n">N</span><span class="p">])</span>
<span class="p">{</span>
    <span class="n">static_vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">N</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">begins</span><span class="p">;</span>
    <span class="n">static_vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">N</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">sizes</span><span class="p">;</span>
    <span class="n">static_vector</span><span class="o">&lt;</span><span class="n">format_spec</span><span class="p">,</span> <span class="n">N</span> <span class="o">/</span> <span class="mi">2</span><span class="o">&gt;</span>     <span class="n">fmts</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">next_length</span><span class="p">(</span><span class="n">xs</span> <span class="o">|</span> <span class="n">drop</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
    <span class="n">begins</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">sizes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// read the FMT part</span>
        <span class="n">fmts</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">parse_format</span><span class="p">(</span><span class="n">xs</span> <span class="o">|</span> <span class="n">drop</span><span class="p">(</span><span class="n">b</span><span class="p">)));</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="c1">// read the STR part</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">next_length</span><span class="p">(</span><span class="n">xs</span> <span class="o">|</span> <span class="n">drop</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
        <span class="n">begins</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="n">sizes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// for simplicity return just as a tuple</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">begins</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="n">fmts</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is it, there’s only a little bit of template metaprogramming code
left to write (see <a class="reference external" href="https://github.com/BoostGSoC17/static-map/blob/development/include/boost/static_map/parse.hpp">full source</a>).
We can now write:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">FORMAT</span><span class="p">(</span><span class="s">&quot;i = %d, %f%% done&quot;</span><span class="p">);</span>
<span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">43.2f</span><span class="p">);</span>   <span class="c1">// OK</span>
<span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>          <span class="c1">// Compile error!</span>
<span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span> <span class="c1">// Compile error!</span>
</pre></div>
</div>
<p>Although we still have to use a macro, we completely avoided the “string
as a tuple of chars” representation, did almost no metaprogramming and
should thus have much better compile times.</p>
</div>
<div class="section" id="bitmaps">
<h3>Bitmaps<a class="headerlink" href="#bitmaps" title="Permalink to this headline">¶</a></h3>
<p>Suppose we have a bitmap (24-bit RGB) icon saved as a <code class="docutils literal"><span class="pre">constexpr</span></code> array of
chars:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">smiley</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="mh">0x25</span><span class="p">,</span> <span class="p">...</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now if a need comes up to convert it to 32-bit RGBA, StaticViews comes in
handy. The only thing we have to do by ourselves is to write a function to
convert <code class="docutils literal"><span class="pre">unsigned</span> <span class="pre">char[3]</span></code> (RGB) into <code class="docutils literal"><span class="pre">uint32_t</span></code> (RGBA). Let’s do it
for little endian:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">xs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span>
         <span class="o">|</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
         <span class="o">|</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">)</span>
         <span class="o">|</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The big endian case is left as an exercise for the reader. If we’re now
given a view of <code class="docutils literal"><span class="pre">char</span></code> representing 24-bit colours, we can easily create
a view of <code class="docutils literal"><span class="pre">uint32_t</span></code>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">V</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">rgb_to_rgba</span><span class="p">(</span><span class="n">V</span><span class="o">&amp;&amp;</span> <span class="n">rgb</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rgb</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">invalid_format_error</span><span class="p">{};</span>

  <span class="k">return</span> <span class="n">rgb</span> <span class="o">|</span> <span class="n">chunk</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
             <span class="o">|</span> <span class="n">map</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">xs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="p">{</span>
                 <span class="k">return</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span>
                      <span class="o">|</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
                      <span class="o">|</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">8</span><span class="p">)</span>
                      <span class="o">|</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span>  <span class="mi">0</span><span class="p">);</span>
               <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What <code class="docutils literal"><span class="pre">chunk(N)</span></code> does is divide the source view into contiguous chunks of
N elements (the last chunk may be shorter). If we want to do the inverse:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">V</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">rgba_to_rgb</span><span class="p">(</span><span class="n">V</span><span class="o">&amp;&amp;</span> <span class="n">rgba</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">rgba</span> <span class="o">|</span> <span class="n">map</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
                  <span class="k">return</span> <span class="n">raw_view</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">{</span>
                    <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x000000FF</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x0000FF00</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mh">0x00FF0000</span><span class="p">)</span>
                  <span class="p">});</span>
                <span class="p">});</span>
              <span class="o">|</span> <span class="n">concat</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We convert each integer into a view of chars and the flatten the view of
views (think monadic bind for lists).</p>
<p>Conversions to a 1-bit bitmaps is a tiny bit trickier. Apart from
conversion from 24-bit RGB to a <code class="docutils literal"><span class="pre">bool</span></code>, we also need to convert 8
<code class="docutils literal"><span class="pre">bool</span></code>’s into a char:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="p">[](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span> <span class="o">|=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Assume that the <code class="docutils literal"><span class="pre">pixel_rgb_to_bw</span></code> takes a view
of 3 <code class="docutils literal"><span class="pre">char</span></code>’s and returns a <code class="docutils literal"><span class="pre">bool</span></code> (true – white, false – black).
Then the complete conversion function becomes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">V</span><span class="o">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">rgb_to_bw</span><span class="p">(</span><span class="n">V</span><span class="o">&amp;&amp;</span> <span class="n">rgb</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">rgb</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">invalid_format_error</span><span class="p">{};</span>

  <span class="k">return</span> <span class="n">rgb</span> <span class="o">|</span> <span class="n">chunk</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
             <span class="o">|</span> <span class="n">map</span><span class="p">(</span><span class="n">pixel_rgb_to_bw</span><span class="p">)</span>
             <span class="o">|</span> <span class="n">chunk</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
             <span class="o">|</span> <span class="n">map</span><span class="p">([](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">bs</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
                  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">c</span> <span class="o">|=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                         <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
                  <span class="p">}</span>
                  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
               <span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="uk-codes">
<h3>UK Codes<a class="headerlink" href="#uk-codes" title="Permalink to this headline">¶</a></h3>
<p>Consider an example of data that rarely changes: postcodes and phone
codes. <a class="reference external" href="https://github.com/BoostGSoC17/static-map/blob/development/example/postcodes.txt">postcodes.txt</a>
and <a class="reference external" href="https://github.com/BoostGSoC17/static-map/blob/development/example/phone_codes.txt">phone_codes.txt</a>
give examples of such data for the UK. We can “load” them at compile by
simply <em>including</em> the files:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">postcode_info</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span><span class="o">*</span>   <span class="n">postcode</span><span class="p">;</span>
    <span class="kt">double</span>        <span class="n">latitude</span><span class="p">;</span>
    <span class="kt">double</span>        <span class="n">longitude</span><span class="p">;</span>
    <span class="kt">char</span> <span class="k">const</span><span class="o">*</span>   <span class="n">town</span><span class="p">;</span>
    <span class="kt">char</span> <span class="k">const</span><span class="o">*</span>   <span class="n">region</span><span class="p">;</span>
    <span class="kt">char</span> <span class="k">const</span><span class="o">*</span>   <span class="n">uk_region</span><span class="p">;</span>
    <span class="kt">char</span> <span class="k">const</span><span class="o">*</span>   <span class="n">country</span><span class="p">;</span>
    <span class="kt">char</span> <span class="k">const</span><span class="o">*</span>   <span class="n">country_string</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">constexpr</span> <span class="n">postcode_info</span> <span class="n">postcodes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#   include &quot;postcodes.txt&quot;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">phone_code_info</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="k">const</span><span class="o">*</span>   <span class="n">phone_code</span><span class="p">;</span>
    <span class="kt">char</span> <span class="k">const</span><span class="o">*</span>   <span class="n">area</span><span class="p">;</span>
    <span class="kt">double</span>        <span class="n">latitude</span><span class="p">;</span>
    <span class="kt">double</span>        <span class="n">longitude</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">constexpr</span> <span class="n">phone_code_info</span> <span class="n">phone_codes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="cp">#   include &quot;phone_codes.txt&quot;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Say, we want a mapping from postcodes to phone codes, i.e. given a
<code class="docutils literal"><span class="pre">postcode</span></code> (as <code class="docutils literal"><span class="pre">char</span> <span class="pre">const*</span></code>) we want to find the corresponding
<code class="docutils literal"><span class="pre">phone_code</span></code> (as <code class="docutils literal"><span class="pre">char</span> <span class="pre">const*</span></code>). There may not be a
<code class="docutils literal"><span class="pre">phone_code_info</span></code> with the exact same location as of the
<code class="docutils literal"><span class="pre">postcode_info</span></code>, we thus look for the closest one:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">constexpr</span> <span class="k">auto</span> <span class="n">find_closest</span> <span class="o">=</span> <span class="p">[](</span><span class="n">postcode_info</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">post</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">phone_codes</span> <span class="o">|</span> <span class="n">min</span><span class="p">([</span><span class="o">&amp;</span><span class="n">post</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">distance</span><span class="p">(</span><span class="n">post</span><span class="p">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">post</span><span class="p">.</span><span class="n">longitude</span><span class="p">,</span>
            <span class="n">x</span><span class="p">.</span><span class="n">latitude</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">longitude</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">};</span>
</pre></div>
</div>
<p>And with that we finally obtain:</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">postcode_to_phone_code</span> <span class="o">=</span> <span class="n">postcodes</span>
    <span class="o">|</span> <span class="n">map</span><span class="p">([](</span><span class="n">postcode_info</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">post</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">post</span><span class="p">,</span> <span class="n">find_closest</span><span class="p">(</span><span class="n">post</span><span class="p">));</span>
      <span class="p">});</span>
    <span class="o">|</span> <span class="n">hashed_view</span><span class="p">(</span><span class="n">compose</span><span class="p">(</span><span class="n">hash_c</span><span class="p">,</span> <span class="n">postcode_info</span><span class="o">::*</span><span class="n">postcode</span><span class="p">));</span>
<span class="c1">//                                ^^^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="c1">//                                with C++17 we can &quot;invoke&quot;</span>
<span class="c1">//                                pointers to member data too.</span>
<span class="c1">//                        ^^^^^^</span>
<span class="c1">//                 a compile-time analogue</span>
<span class="c1">//                 of hash&lt;void&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">match</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">postcode_to_phone_code</span><span class="p">](</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">postcode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">find_if</span>
        <span class="p">(</span> <span class="n">postcode_to_phone_code</span><span class="p">[</span><span class="n">hash_c</span><span class="p">(</span><span class="n">postcode</span><span class="p">)]</span>
        <span class="p">,</span> <span class="p">[</span><span class="n">postcode</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">info</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">return</span> <span class="n">equal_c</span><span class="p">(</span><span class="n">postcode</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">postcode</span><span class="p">);</span>
<span class="c1">//                   ^^^^^^^</span>
<span class="c1">//              a compile-time analogue</span>
<span class="c1">//              of equal&lt;void&gt;</span>
          <span class="p">}</span>
        <span class="p">).</span><span class="n">second</span><span class="p">.</span><span class="n">phone_code</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Now we can do <code class="docutils literal"><span class="pre">match(postcode)</span></code> which gives us a <code class="docutils literal"><span class="pre">phone_code</span></code> closest
to the input postcode. Oh, yes, and if <code class="docutils literal"><span class="pre">postcodes</span></code> doesn’t contain the
<code class="docutils literal"><span class="pre">postcode</span></code> we get a compile error.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Boost.StaticViews</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests.html">Testing</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to Boost.StaticViews’s documentation!</a></li>
      <li>Next: <a href="reference.html" title="next chapter">Reference</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Tom Westerhout.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/getting_started.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>